{"version":3,"file":"meeussunmoon.min.mjs","sources":["../src/auxMath.ts","../src/timeConversions.ts","../src/settings.ts","../src/constants.ts","../src/sunTimes.ts","../src/moonPhases.ts","../src/index.ts"],"sourcesContent":["/**\r\n * Converts angles in degrees to radians.\r\n * @param {number} deg Angle in degrees.\r\n * @returns {number} Angle in radians.\r\n */\r\nconst deg2rad = (deg: number): number => deg * 0.017453292519943295;\r\n\r\n/**\r\n * Converts angles in radians to degrees.\r\n * @param {number} rad Angle in radians.\r\n * @returns {number} Angle in degrees.\r\n */\r\nconst rad2deg = (rad: number): number => rad * 57.29577951308232;\r\n\r\n/**\r\n * Calculates the sine of an angle given in degrees.\r\n * @param {number} deg Angle in degrees.\r\n * @returns {number} Sine of the angle.\r\n */\r\nconst sind = (deg: number): number => Math.sin(deg2rad(deg));\r\n\r\n/**\r\n * Calculates the cosine of an angle given in degrees.\r\n * @param {number} deg Angle in degrees.\r\n * @returns {number} Cosine of the angle.\r\n */\r\nconst cosd = (deg: number): number => Math.cos(deg2rad(deg));\r\n\r\n/**\r\n * Reduces an angle to the interval 0-360°.\r\n * @param {number} angle Angle in degrees.\r\n * @returns {number} Reduced angle in degrees.\r\n */\r\nconst reduceAngle = (angle: number): number => angle - (360 * Math.floor(angle / 360));\r\n\r\n/**\r\n * Evaluates a polynomial in the form A + Bx + Cx^2...\r\n * @param {number} variable Value of x in the polynomial.\r\n * @param {array} coeffs Array of coefficients [A, B, C...].\r\n * @returns {number} Sum of the polynomial.\r\n */\r\nconst polynomial = (variable: number, coeffs: Array<number>): number => {\r\n    let varPower = 1;\r\n    return coeffs.reduce((accumulator, currentValue) => {\r\n        accumulator += varPower * currentValue;\r\n        varPower *= variable;\r\n        return accumulator;\r\n    }, 0.0);\r\n};\r\n\r\n/**\r\n * Interpolates a value from 3 known values (see AA p24 Eq3.3).\r\n * @param {number} y1 Start value of the interval.\r\n * @param {number} y2 Middle value of the interval.\r\n * @param {number} y3 End value of the interval.\r\n * @param {number} n Location (-0.5 >= n >= 0.5) of result in the interval.\r\n * @param {boolean} normalize Whether the final result should be normalized.\r\n * @returns {number} Interpolated result.\r\n */\r\nconst interpolateFromThree = (y1: number, y2: number, y3: number, n: number, normalize: boolean = false): number => {\r\n    let a = y2 - y1;\r\n    let b = y3 - y2;\r\n    if (typeof normalize !== 'undefined' && normalize) {\r\n        if (a < 0) {\r\n            a += 360;\r\n        }\r\n        if (b < 0) {\r\n            b += 360;\r\n        }\r\n    }\r\n    const c = b - a;\r\n    return y2 + (n / 2) * (a + b + n * c);\r\n};\r\n\r\nexport { deg2rad, rad2deg, sind, cosd, reduceAngle, polynomial, interpolateFromThree };\r\n","import { DateTime } from 'luxon';\r\nimport { polynomial } from './auxMath';\r\n\r\n/**\r\n * Converts a datetime in UTC to the corresponding Julian Date (see AA p60f).\r\n * @param {DateTime} datetime Datetime to be converted.\r\n * @returns {number} Julian date (fractional number of days since 1 January\r\n *     4713BC according to the proleptic Julian calendar.\r\n */\r\nconst datetimeToJD = (datetime: DateTime): number => {\r\n    let Y = datetime.year;\r\n    let M = datetime.month;\r\n    const D = datetime.day + (datetime.hour + (datetime.minute + datetime.second / 60) / 60) / 24;\r\n    if (M < 3) {\r\n        Y -= 1;\r\n        M += 12;\r\n    }\r\n    const A = Math.floor(Y / 100);\r\n    // Need a different B if we are before introduction of the Gregorian Calendar\r\n    const gregorianCutoff = DateTime.fromISO('1582-10-15T12:00:00Z', { zone: 'UTC' });\r\n    let B = 0;\r\n    if (datetime > gregorianCutoff) {\r\n        B = 2 - A + Math.floor(A / 4);\r\n    }\r\n    return Math.floor(365.25 * (Y + 4716)) + Math.floor(30.6001 * (M + 1)) + D + B - 1524.5;\r\n};\r\n\r\n/**\r\n * Converts a Julian Date to the corresponding datetime in UTC (see AA p63).\r\n * @param {number} JD Julian date to be converted\r\n * @returns {DateTime} Datetime corresponding to the given Julian date.\r\n */\r\nconst JDToDatetime = (JD: number): DateTime => {\r\n    JD += 0.5;\r\n    const Z = Math.floor(JD);\r\n    const F = JD - Z;\r\n    let A = Z;\r\n    if (Z >= 2299161) {\r\n        const alpha = Math.floor((Z - 1867216.25) / 36524.25);\r\n        A += 1 + alpha - Math.floor(alpha / 4);\r\n    }\r\n    const B = A + 1524;\r\n    const C = Math.floor((B - 122.1) / 365.25);\r\n    const D = Math.floor(365.25 * C);\r\n    const E = Math.floor((B - D) / 30.6001);\r\n    const fracDay = B - D - Math.floor(30.6001 * E) + F;\r\n    const day = Math.floor(fracDay);\r\n    const hour = Math.floor((fracDay - day) * 24);\r\n    const minute = Math.floor(((fracDay - day) * 24 - hour) * 60);\r\n    const second = Math.floor((((fracDay - day) * 24 - hour) * 60 - minute) * 60);\r\n    let month = E - 1;\r\n    if (E > 13) {\r\n        month -= 12;\r\n    }\r\n    let year = C - 4715;\r\n    if (month > 2) {\r\n        year -= 1;\r\n    }\r\n    return DateTime.fromISO('2000-01-01T12:00:00Z', { zone: 'UTC' })\r\n        // eslint-disable-next-line sort-keys\r\n        .set({ year, month, day, hour, minute, second });\r\n};\r\n\r\n/**\r\n * Converts a Julian date to the number of Julian centuries since\r\n * 2000-01-01T12:00:00Z (see AA p87 Eq12.1).\r\n * @param {number} JD Julian date.\r\n * @returns {number} T.\r\n */\r\nconst JDToT = (JD: number): number => (JD - 2451545) / 36525;\r\n\r\n/**\r\n * Converts a datetime in UTC to the number of Julian centuries since\r\n * 2000-01-01T12:00:00Z.\r\n * @param {DateTime} datetime Datetime to be converted.\r\n * @returns {number} T.\r\n */\r\nconst datetimeToT = (datetime: DateTime): number => JDToT(datetimeToJD(datetime));\r\n\r\n/* eslint-disable complexity */\r\n/**\r\n * Calculates the value of ΔT=TT−UT (see\r\n * http://eclipse.gsfc.nasa.gov/SEcat5/deltatpoly.html).\r\n * @param {DateTime} datetime Datetime for which ΔT should be calculated.\r\n * @returns {number} ΔT.\r\n */\r\nconst DeltaT = (datetime: DateTime): number => {\r\n    let y = datetime.year;\r\n    y += (datetime.month - 0.5) / 12;\r\n    let u;\r\n    let t;\r\n    switch (true) {\r\n        case y < -1999 || y > 3000:\r\n            throw new RangeError('DeltaT can only be calculated between 1999 BCE and 3000 CE');\r\n        case y < -500:\r\n            u = (y - 1820) / 100;\r\n            return -20 + 32 * u ** 2;\r\n        case y < 500:\r\n            u = y / 100;\r\n            return polynomial(u, [10583.6, -1014.41, 33.78311, -5.952053, -0.1798452, 0.022174192, 0.0090316521]);\r\n        case y < 1600:\r\n            u = (y - 1000) / 100;\r\n            return polynomial(u, [1574.2, -556.01, 71.23472, 0.319781, -0.8503463, -0.005050998, 0.0083572073]);\r\n        case y < 1700:\r\n            t = y - 1600;\r\n            return polynomial(t, [120, -0.9808, -0.01532, 1 / 7129]);\r\n        case y < 1800:\r\n            t = y - 1700;\r\n            return polynomial(t, [8.83, 0.1603, -0.0059285, 0.00013336, -1 / 1174000]);\r\n        case y < 1860:\r\n            t = y - 1800;\r\n            return polynomial(t,\r\n                [13.72, -0.332447, 0.0068612, 0.0041116, -0.00037436, 0.0000121272, -0.0000001699, 0.000000000875]);\r\n        case y < 1900:\r\n            t = y - 1860;\r\n            return polynomial(t, [7.62, 0.5737, -0.251754, 0.01680668, -0.0004473624, 1 / 233174]);\r\n        case y < 1920:\r\n            t = y - 1900;\r\n            return polynomial(t, [-2.79, 1.494119, -0.0598939, 0.0061966, -0.000197]);\r\n        case y < 1941:\r\n            t = y - 1920;\r\n            return polynomial(t, [21.20, 0.84493, -0.076100, 0.0020936]);\r\n        case y < 1961:\r\n            t = y - 1950;\r\n            return polynomial(t, [29.07, 0.407, -1 / 233, 1 / 2547]);\r\n        case y < 1986:\r\n            t = y - 1975;\r\n            return polynomial(t, [45.45, 1.067, -1 / 260, -1 / 718]);\r\n        case y < 2005:\r\n            t = y - 2000;\r\n            return polynomial(t, [63.86, 0.3345, -0.060374, 0.0017275, 0.000651814, 0.00002373599]);\r\n        case y < 2050:\r\n            t = y - 2000;\r\n            return polynomial(t, [62.92, 0.32217, 0.005589]);\r\n        case y < 2150:\r\n            return -20 + 32 * ((y - 1820) / 100) ** 2 - 0.5628 * (2150 - y);\r\n        default:\r\n            u = (y - 1820) / 100;\r\n            return -20 + 32 * u ** 2;\r\n    }\r\n};\r\n/* eslint-enable complexity */\r\n\r\n/**\r\n * Calculates an approximate value for k (the fractional number of new moons\r\n * since 2000-01-06).\r\n * @param {DateTime} datetime Datetime for which k is calculated.\r\n * @returns {number} k.\r\n */\r\nconst approxK = (datetime: DateTime): number => {\r\n    const year = datetime.year + (datetime.month) / 12 +\r\n        datetime.day / 365.25;\r\n    return (year - 2000) * 12.3685;\r\n};\r\n\r\n/**\r\n * Calculates T from k.\r\n * @param {number} k Fractional number of new moons since 2000-01-06.\r\n * @returns {number} T Fractional num. of centuries since 2000-01-01:12:00:00Z.\r\n */\r\nconst kToT = (k: number): number => k / 1236.85;\r\n\r\nexport { datetimeToJD, JDToDatetime, JDToT, datetimeToT, DeltaT, approxK, kToT };\r\n","import { MeeusSunMoonSettings } from './types';\r\n\r\nlet roundToNearestMinute = false;\r\nlet returnTimeForNoEventCase = false;\r\nlet dateFormatKeys = {\r\n    SUN_HIGH: '‡',\r\n    SUN_LOW: '†',\r\n};\r\n\r\nconst settings = (settings: MeeusSunMoonSettings) => {\r\n    if (typeof settings.roundToNearestMinute === 'boolean') {\r\n        roundToNearestMinute = settings.roundToNearestMinute;\r\n    }\r\n    if (typeof settings.returnTimeForNoEventCase === 'boolean') {\r\n        returnTimeForNoEventCase = settings.returnTimeForNoEventCase;\r\n    }\r\n    if (typeof settings.dateFormatKeys === 'object') {\r\n        dateFormatKeys = settings.dateFormatKeys;\r\n    }\r\n};\r\n\r\nexport { settings, roundToNearestMinute, returnTimeForNoEventCase, dateFormatKeys };\r\n","/** See AA p144 */\r\nconst sunMeanAnomaly = [357.52772, 35999.050340, -0.0001603, -1 / 300000];\r\n\r\n/** See AA p163 Eq 25.2 */\r\nconst sunMeanLongitude = [280.46646, 36000.76983, 0.0003032];\r\n\r\n/** See AA p147 Eq22.3 */\r\nconst meanObliquityOfEcliptic =\r\n    [84381.448 / 3600, -4680.93 / 3600, -1.55 / 3600, 1999.25 / 3600, -51.38 / 3600, -249.67 / 3600, -39.05 / 3600,\r\n        7.12 / 3600, 27.87 / 3600, 5.79 / 3600, 2.45 / 3600];\r\n\r\n/** See AA p144 */\r\nconst moonArgumentOfLatitude =\r\n    [93.27191, 483202.017538, -0.0036825, 1 / 327270];\r\n\r\n/** See AA p144 */\r\nconst moonAscendingNodeLongitude = [125.04452, -1934.136261, 0.0020708, 1 / 450000];\r\n\r\n/** See AA p144 */\r\nconst moonMeanAnomaly = [134.96298, 477198.867398, 0.0086972, 1 / 56250];\r\n\r\n/** See AA p144 */\r\nconst moonMeanElongation = [297.85036, 445267.111480, -0.0019142, 1 / 189474];\r\n\r\n/* eslint-disable no-multi-spaces, array-bracket-spacing */\r\n/**\r\n * Nutations in longitude and obliquity\r\n * See AA p145f\r\n */\r\nconst nutations =\r\n    [\r\n        [ 0,  0,  0,  0, 1, -171996, -174.2, 92025,  8.9],\r\n        [-2,  0,  0,  2, 2,  -13187,   -1.6,  5736, -3.1],\r\n        [ 0,  0,  0,  2, 2,   -2274,   -0.2,   977, -0.5],\r\n        [ 0,  0,  0,  0, 2,    2062,    0.2,  -895,  0.5],\r\n        [ 0,  1,  0,  0, 0,    1426,   -3.4,    54, -0.1],\r\n        [ 0,  0,  1,  0, 0,     712,    0.1,    -7,    0],\r\n        [-2,  1,  0,  2, 2,    -517,    1.2,   224, -0.6],\r\n        [ 0,  0,  0,  2, 1,    -386,   -0.4,   200,    0],\r\n        [ 0,  0,  1,  2, 2,    -301,      0,   129, -0.1],\r\n        [-2, -1,  0,  2, 2,     217,   -0.5,   -95,  0.3],\r\n        [-2,  0,  1,  0, 0,    -158,      0,     0,    0],\r\n        [-2,  0,  0,  2, 1,     129,    0.1,   -70,    0],\r\n        [ 0,  0, -1,  2, 2,     123,      0,   -53,    0],\r\n        [ 2,  0,  0,  0, 0,      63,      0,     0,    0],\r\n        [ 0,  0,  1,  0, 1,      63,    0.1,   -33,    0],\r\n        [ 2,  0, -1,  2, 2,     -59,      0,    26,    0],\r\n        [ 0,  0, -1,  0, 1,     -58,   -0.1,    32,    0],\r\n        [ 0,  0,  1,  2, 1,     -51,      0,    27,    0],\r\n        [-2,  0,  2,  0, 0,      48,      0,     0,    0],\r\n        [ 0,  0, -2,  2, 1,      46,      0,   -24,    0],\r\n        [ 2,  0,  0,  2, 2,     -38,      0,    16,    0],\r\n        [ 0,  0,  2,  2, 2,     -31,      0,    13,    0],\r\n        [ 0,  0,  2,  0, 0,      29,      0,     0,    0],\r\n        [-2,  0,  1,  2, 2,      29,      0,   -12,    0],\r\n        [ 0,  0,  0,  2, 0,      26,      0,     0,    0],\r\n        [-2,  0,  0,  2, 0,     -22,      0,     0,    0],\r\n        [ 0,  0, -1,  2, 1,      21,      0,   -10,    0],\r\n        [ 0,  2,  0,  0, 0,      17,   -0.1,     0,    0],\r\n        [ 2,  0, -1,  0, 1,      16,      0,    -8,    0],\r\n        [-2,  2,  0,  2, 2,     -16,    0.1,     7,    0],\r\n        [ 0,  1,  0,  0, 1,     -15,      0,     9,    0],\r\n        [-2,  0,  1,  0, 1,     -13,      0,     7,    0],\r\n        [ 0, -1,  0,  0, 1,     -12,      0,     6,    0],\r\n        [ 0,  0,  2, -2, 0,      11,      0,     0,    0],\r\n        [ 2,  0, -1,  2, 1,     -10,      0,     5,    0],\r\n        [ 2,  0,  1,  2, 2,     -8,       0,     3,    0],\r\n        [ 0,  1,  0,  2, 2,      7,       0,    -3,    0],\r\n        [-2,  1,  1,  0, 0,     -7,       0,     0,    0],\r\n        [ 0, -1,  0,  2, 2,     -7,       0,     3,    0],\r\n        [ 2,  0,  0,  2, 1,     -7,       0,     3,    0],\r\n        [ 2,  0,  1,  0, 0,      6,       0,     0,    0],\r\n        [-2,  0,  2,  2, 2,      6,       0,    -3,    0],\r\n        [-2,  0,  1,  2, 1,      6,       0,    -3,    0],\r\n        [ 2,  0, -2,  0, 1,     -6,       0,     3,    0],\r\n        [ 2,  0,  0,  0, 1,     -6,       0,     3,    0],\r\n        [ 0, -1,  1,  0, 0,      5,       0,     0,    0],\r\n        [-2, -1,  0,  2, 1,     -5,       0,     3,    0],\r\n        [-2,  0,  0,  0, 1,     -5,       0,     3,    0],\r\n        [ 0,  0,  2,  2, 1,     -5,       0,     3,    0],\r\n        [-2,  0,  2,  0, 1,      4,       0,     0,    0],\r\n        [-2,  1,  0,  2, 1,      4,       0,     0,    0],\r\n        [ 0,  0,  1, -2, 0,      4,       0,     0,    0],\r\n        [-1,  0,  1,  0, 0,     -4,       0,     0,    0],\r\n        [-2,  1,  0,  0, 0,     -4,       0,     0,    0],\r\n        [ 1,  0,  0,  0, 0,     -4,       0,     0,    0],\r\n        [ 0,  0,  1,  2, 0,      3,       0,     0,    0],\r\n        [ 0,  0, -2,  2, 2,     -3,       0,     0,    0],\r\n        [-1, -1,  1,  0, 0,     -3,       0,     0,    0],\r\n        [ 0,  1,  1,  0, 0,     -3,       0,     0,    0],\r\n        [ 0, -1,  1,  2, 2,     -3,       0,     0,    0],\r\n        [ 2, -1, -1,  2, 2,     -3,       0,     0,    0],\r\n        [ 0,  0,  3,  2, 2,      3,       0,     0,    0],\r\n        [ 2, -1,  0,  2, 2,     -3,       0,     0,    0],\r\n    ];\r\n/* eslint-enable no-multi-spaces, array-bracket-spacing */\r\n\r\nexport { sunMeanAnomaly, sunMeanLongitude, meanObliquityOfEcliptic, moonArgumentOfLatitude, moonAscendingNodeLongitude,\r\n    moonMeanAnomaly, moonMeanElongation, nutations };\r\n","import * as constants from './constants';\r\nimport { DateTime, NoEventCode, RiseSetFlag } from './types';\r\nimport { DeltaT, datetimeToT } from './timeConversions';\r\nimport { cosd, interpolateFromThree, polynomial, rad2deg, reduceAngle, sind } from './auxMath';\r\nimport { returnTimeForNoEventCase, roundToNearestMinute } from './settings';\r\n\r\n/**\r\n * Calculates the solar transit time on a date at a given longitude (see AA\r\n * p102f).\r\n * @param {DateTime} datetime Date for which transit is calculated.\r\n * @param {number} L Longitude.\r\n * @returns {DateTime} Solar transit time.\r\n */\r\nconst sunTransit = (datetime: DateTime, L: number): DateTime => {\r\n    const timezone = datetime.zone;\r\n    let transit = datetime.set({ hour: 0, minute: 0, second: 0, millisecond: 0 })\r\n        .setZone('UTC', { keepLocalTime: true });\r\n    const deltaT = DeltaT(transit);\r\n    const T = datetimeToT(transit);\r\n    const Theta0 = apparentSiderealTimeGreenwich(T);\r\n    // Want 0h TD for this, not UT\r\n    const TD = T - (deltaT / (3600 * 24 * 36525));\r\n    const alpha = sunApparentRightAscension(TD);\r\n    // Sign flip for longitude from AA as we take East as positive\r\n    let m = (alpha - L - Theta0) / 360;\r\n    m = normalizeM(m, datetime.offset);\r\n    const DeltaM = sunTransitCorrection(T, Theta0, deltaT, L, m);\r\n    m += DeltaM;\r\n    transit = transit.plus({ seconds: Math.floor(m * 3600 * 24 + 0.5) });\r\n    if (roundToNearestMinute) {\r\n        transit = transit.plus({ seconds: 30 }).set({ second: 0 });\r\n    }\r\n    return transit.setZone(timezone);\r\n};\r\n\r\n/**\r\n * Calculates the sunrise or sunset time on a date at a given latitude and\r\n * longitude (see AA p102f).\r\n * @param {DateTime} datetime Date for which sunrise or sunset is calculated.\r\n * @param {number} phi Latitude.\r\n * @param {number} L Longitude.\r\n * @param {string} flag 'RISE' or 'SET' depending on which event should be\r\n *     calculated.\r\n * @param {number} offset number of degrees below the horizon for the desired\r\n *     event (50/60 for sunrise/set, 6 for civil, 12 for nautical, 18 for\r\n *     astronomical dawn/dusk.\r\n * @returns {DateTime} Sunrise or sunset time.\r\n */\r\n// eslint-disable-next-line complexity,require-jsdoc\r\nconst sunRiseSet = (datetime: DateTime, phi: number, L: number, flag: RiseSetFlag, offset: number = 50 / 60):\r\n    DateTime => {\r\n    const timezone = datetime.zone;\r\n    let suntime = datetime.set({ hour: 0, minute: 0, second: 0, millisecond: 0 })\r\n        .setZone('UTC', { keepLocalTime: true });\r\n    const deltaT = DeltaT(suntime);\r\n    const T = datetimeToT(suntime);\r\n    const Theta0 = apparentSiderealTimeGreenwich(T);\r\n    // Want 0h TD for this, not UT\r\n    const TD = T - (deltaT / (3600 * 24 * 36525));\r\n    const alpha = sunApparentRightAscension(TD);\r\n    const delta = sunApparentDeclination(TD);\r\n    const H0 = approxLocalHourAngle(phi, delta, offset);\r\n    // Sign flip for longitude from AA as we take East as positive\r\n    let m0 = (alpha - L - Theta0) / 360;\r\n    m0 = normalizeM(m0, datetime.offset);\r\n    let m;\r\n    if (flag === 'RISE') {\r\n        m = m0 - H0 / 360;\r\n    } else {\r\n        m = m0 + H0 / 360;\r\n    }\r\n    let counter = 0;\r\n    let DeltaM = 1;\r\n    // Repeat if correction is larger than ~9s\r\n    while ((Math.abs(DeltaM) > 0.0001) && (counter < 3)) {\r\n        DeltaM = sunRiseSetCorrection(T, Theta0, deltaT, phi, L, m, offset);\r\n        m += DeltaM;\r\n        counter++;\r\n    }\r\n    if (m > 0) {\r\n        suntime = suntime.plus({ seconds: Math.floor(m * 3600 * 24 + 0.5) });\r\n    } else {\r\n        suntime = suntime.minus({ seconds: Math.floor(m * 3600 * 24 + 0.5) });\r\n    }\r\n    if (roundToNearestMinute) {\r\n        suntime = suntime.plus({ seconds: 30 }).set({ second: 0 });\r\n    }\r\n    return suntime.setZone(timezone);\r\n};\r\n\r\n/**\r\n * Returns a fixed time as given by the hour parameter, an hour later during DST) if the\r\n * specified event does not occur on the date and returnTimeForNoEventCase is true. If\r\n * false, return whether the reason for no event is the sun being too high ('SUN_HIGH')\r\n * or too low ('SUN_LOW').\r\n * @param {DateTime} date The original date from which the event was calculated.\r\n * @param {string|undefined} errorCode The error code in case no event was found\r\n * @param {number} hour Hour to which the returned datetime should be set.\r\n * @param {number} minute Minute to which the returned datetime should be set.\r\n * @returns {(DateTime|string)} Time given by parameter 'hour' (+ correction for\r\n *     DST if applicable) or a string indicating why there was no event ('SUN_HIGH'\r\n *     or 'SUN_LOW')\r\n */\r\nconst handleNoEventCase = (date: DateTime, errorCode: NoEventCode, hour: number, minute: number = 0):\r\n    (DateTime | NoEventCode) => {\r\n    if (returnTimeForNoEventCase) {\r\n        const returnDate = date.set({ hour, minute, second: 0 }).plus({ minutes: date.isInDST ? 60 : 0 });\r\n        (returnDate as DateTime).errorCode = errorCode;\r\n        return returnDate;\r\n    }\r\n    return errorCode;\r\n};\r\n\r\n/**\r\n * Calculates the approximate local hour angle of the sun at sunrise or sunset.\r\n * @param {number} phi Latitude (see AA p102 Eq15.1).\r\n * @param {number} delta Apparent declination of the sun.\r\n * @param {number} offset number of degrees below the horizon for the desired\r\n *     event (50/60 for sunrise/set, 6 for civil, 12 for nautical, 18 for\r\n *     astronomical dawn/dusk.\r\n * @returns {number} Approximate local hour angle.\r\n */\r\nconst approxLocalHourAngle = (phi: number, delta: number, offset: number): number => {\r\n    const cosH0 = (sind(-offset) -\r\n        sind(phi) * sind(delta)) /\r\n        (cosd(phi) * cosd(delta));\r\n    if (cosH0 < -1) {\r\n        throw noEventCodes.SUN_HIGH;\r\n    } else if (cosH0 > 1) {\r\n        throw noEventCodes.SUN_LOW;\r\n    }\r\n    return rad2deg(Math.acos(cosH0));\r\n};\r\n\r\n/**\r\n * Normalizes a fractional time of day to be on the correct date.\r\n * @param {number} m Fractional time of day\r\n * @param {number} utcOffset Offset in minutes from UTC.\r\n * @returns {number} m Normalized m.\r\n */\r\nconst normalizeM = (m: number, utcOffset: number): number => {\r\n    const localM = m + utcOffset / 1440;\r\n    if (localM < 0) {\r\n        return m + 1;\r\n    } else if (localM > 1) {\r\n        return m - 1;\r\n    }\r\n    return m;\r\n};\r\n\r\n/**\r\n * Calculates the correction for the solar transit time (see AA p103).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @param {number} Theta0 Apparent sidereal time at Greenwich.\r\n * @param {number} deltaT ΔT = TT − UT.\r\n * @param {number} L Longitude.\r\n * @param {number} m Fractional time of day of the event.\r\n * @returns {number} Currection for the solar transit time.\r\n */\r\nconst sunTransitCorrection = (T: number, Theta0: number, deltaT: number, L: number, m: number): number => {\r\n    const theta0 = Theta0 + 360.985647 * m;\r\n    const n = m + deltaT / 864000;\r\n    const alpha = interpolatedRa(T, n);\r\n    const H = localHourAngle(theta0, L, alpha);\r\n    return -H / 360;\r\n};\r\n\r\n/**\r\n * Calculates the correction for the sunrise/sunset time (see AA p103).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @param {number} Theta0 Apparent sidereal time at Greenwich.\r\n * @param {number} deltaT ΔT = TT − UT.\r\n * @param {number} phi Latitude.\r\n * @param {number} L Longitude.\r\n * @param {number} m Fractional time of day of the event.\r\n * @param {number} offset number of degrees below the horizon for the desired\r\n *     event (50/60 for sunrise/set, 6 for civil, 12 for nautical, 18 for\r\n *     astronomical dawn/dusk.\r\n * @returns {number} Correction for the sunrise/sunset time.\r\n */\r\nconst sunRiseSetCorrection =\r\n    (T: number, Theta0: number, deltaT: number, phi: number, L: number, m: number, offset: number): number => {\r\n        const theta0 = Theta0 + 360.985647 * m;\r\n        const n = m + deltaT / 864000;\r\n        const alpha = interpolatedRa(T, n);\r\n        const delta = interpolatedDec(T, n);\r\n        const H = localHourAngle(theta0, L, alpha);\r\n        const h = altitude(phi, delta, H);\r\n        return (h + offset) / (360 * cosd(delta) * cosd(phi) * sind(H));\r\n    };\r\n\r\n/**\r\n * Calculates the local hour angle of the sun (see AA p103).\r\n * @param {number} theta0 Sidereal time at Greenwich in degrees.\r\n * @param {number} L Longitude.\r\n * @param {number} alpha Apparent right ascension of the sun.\r\n * @returns {number} Local hour angle of the sun.\r\n */\r\nconst localHourAngle = (theta0: number, L: number, alpha: number): number => {\r\n    // Sign flip for longitude\r\n    let H = reduceAngle(theta0 + L - alpha);\r\n    if (H > 180) {\r\n        H -= 360;\r\n    }\r\n    return H;\r\n};\r\n\r\n/**\r\n * Calculates the altitude of the sun above the horizon (see AA P93 Eq13.6).\r\n * @param {number} phi Latitude.\r\n * @param {number} delta Apparent declination of the sun.\r\n * @param {number} H Local hour angle of the sun.\r\n * @returns {number} Altitude of the sun above the horizon.\r\n */\r\nconst altitude = (phi: number, delta: number, H: number): number => rad2deg(Math.asin(\r\n    sind(phi) * sind(delta) + cosd(phi) * cosd(delta) * cosd(H)));\r\n\r\n/**\r\n * Interpolates the sun's right ascension (see AA p103).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @param {number} n Fractional time of day of the event corrected by ΔT.\r\n * @returns {number} Interpolated right ascension.\r\n */\r\nconst interpolatedRa = (T: number, n: number): number => {\r\n    const alpha1 = sunApparentRightAscension(T - (1 / 36525));\r\n    const alpha2 = sunApparentRightAscension(T);\r\n    const alpha3 = sunApparentRightAscension(T + (1 / 36525));\r\n    const alpha = interpolateFromThree(alpha1, alpha2, alpha3, n, true);\r\n    return reduceAngle(alpha);\r\n};\r\n\r\n/**\r\n * Interpolates the sun's declination (see AA p103).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @param {number} n Fractional time of day of the event corrected by ΔT.\r\n * @returns {number} Interpolated declination.\r\n */\r\nconst interpolatedDec = (T: number, n: number): number => {\r\n    const delta1 = sunApparentDeclination(T - (1 / 36525));\r\n    const delta2 = sunApparentDeclination(T);\r\n    const delta3 = sunApparentDeclination(T + (1 / 36525));\r\n    const delta = interpolateFromThree(delta1, delta2, delta3, n);\r\n    return reduceAngle(delta);\r\n};\r\n\r\n/**\r\n * Calculates the apparent right ascension of the sun (see AA p165 Eq25.6).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Apparent right ascension of the sun.\r\n */\r\nconst sunApparentRightAscension = (T: number): number => {\r\n    const Omega = moonAscendingNodeLongitude(T);\r\n    const epsilon = trueObliquityOfEcliptic(T) + 0.00256 * cosd(Omega);\r\n    const lambda = sunApparentLongitude(T);\r\n    const alpha = rad2deg(Math.atan2(cosd(epsilon) * sind(lambda), cosd(lambda)));\r\n    return reduceAngle(alpha);\r\n};\r\n\r\n/**\r\n * Calculates the apparent declination of the sun (see AA p165 Eq25.7).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Apparent declination of the sun.\r\n */\r\nconst sunApparentDeclination = (T: number): number => {\r\n    const Omega = moonAscendingNodeLongitude(T);\r\n    const epsilon = trueObliquityOfEcliptic(T) + 0.00256 * cosd(Omega);\r\n    const lambda = sunApparentLongitude(T);\r\n    return rad2deg(Math.asin(sind(epsilon) * sind(lambda)));\r\n};\r\n\r\n/**\r\n * Calculates the apparent sidereal time at Greenwich (see AA p88).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Apparent sidereal time at Greenwich\r\n */\r\nconst apparentSiderealTimeGreenwich = (T: number): number => {\r\n    const theta0 = meanSiderealTimeGreenwich(T);\r\n    const epsilon = trueObliquityOfEcliptic(T);\r\n    const DeltaPsi = nutationInLongitude(T);\r\n    const theta = theta0 + DeltaPsi * cosd(epsilon);\r\n    return reduceAngle(theta);\r\n};\r\n\r\n/**\r\n * Calculates the mean sidereal time at Greenwich (see AA p88 Eq12.4).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Mean sidereal time at Greenwich\r\n */\r\nconst meanSiderealTimeGreenwich = (T: number): number => {\r\n    const JD2000 = T * 36525;\r\n    return 280.46061837 + 360.98564736629 * JD2000 + 0.000387933 * T ** 2 - T ** 3 / 38710000;\r\n};\r\n\r\n/**\r\n * Calculates the true obliquity of the ecliptic (see AA p147).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} True obliquity of the ecliptic.\r\n */\r\nconst trueObliquityOfEcliptic = (T: number): number => {\r\n    const epsilon0 = meanObliquityOfEcliptic(T);\r\n    const DeltaEpsilon = nutationInObliquity(T);\r\n    return epsilon0 + DeltaEpsilon;\r\n};\r\n\r\n/**\r\n * Calculates the mean obliquity of the ecliptic (see AA p147 Eq 22.3).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Mean obliquity of the ecliptic.\r\n */\r\nconst meanObliquityOfEcliptic = (T: number): number => {\r\n    const U = T / 100;\r\n    return polynomial(U, constants.meanObliquityOfEcliptic);\r\n};\r\n\r\n/**\r\n * Calculates the apparent longitude of the sun (see AA p164).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Apparent longitude of the sun.\r\n */\r\nconst sunApparentLongitude = (T: number): number => {\r\n    const Sol = sunTrueLongitude(T);\r\n    const Omega = moonAscendingNodeLongitude(T);\r\n    return Sol - 0.00569 - 0.00478 * sind(Omega);\r\n};\r\n\r\n/**\r\n * Calculates the true longitude of the sun (see AA p164).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} True longitude of the sun.\r\n */\r\nconst sunTrueLongitude = (T: number): number => {\r\n    const L0 = sunMeanLongitude(T);\r\n    const C = sunEquationOfCenter(T);\r\n    return L0 + C;\r\n};\r\n\r\n/**\r\n * Calculates the equation of center of the sun (see AA p164).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Equation of center of the sun.\r\n */\r\nconst sunEquationOfCenter = (T: number): number => {\r\n    const M = sunMeanAnomaly(T);\r\n    return (1.914602 - 0.004817 * T - 0.000014 * T ** 2) * sind(M) +\r\n        (0.019993 - 0.000101 * T) * sind(2 * M) + 0.000290 * sind(3 * M);\r\n};\r\n\r\n/**\r\n * Calculates the nutation in longitude of the sun (see AA p144ff).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Nutation in longitude of the sun.\r\n */\r\nconst nutationInLongitude = (T: number): number => {\r\n    const D = moonMeanElongation(T);\r\n    const M = sunMeanAnomaly(T);\r\n    const MPrime = moonMeanAnomaly(T);\r\n    const F = moonArgumentOfLatitude(T);\r\n    const Omega = moonAscendingNodeLongitude(T);\r\n    let DeltaPsi = 0;\r\n    let sineArg;\r\n    for (let i = 0; i < 63; i++) {\r\n        sineArg = constants.nutations[i][0] * D + constants.nutations[i][1] * M + constants.nutations[i][2] * MPrime +\r\n            constants.nutations[i][3] * F + constants.nutations[i][4] * Omega;\r\n        DeltaPsi += (constants.nutations[i][5] + constants.nutations[i][6] * T) * sind(sineArg);\r\n    }\r\n    return DeltaPsi / 36000000;\r\n};\r\n\r\n/**\r\n * Calculates the nutation in obliquity of the sun (see AA p144ff).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Nutation in obliquity of the sun.\r\n */\r\nconst nutationInObliquity = (T: number): number => {\r\n    const D = moonMeanElongation(T);\r\n    const M = sunMeanAnomaly(T);\r\n    const MPrime = moonMeanAnomaly(T);\r\n    const F = moonArgumentOfLatitude(T);\r\n    const Omega = moonAscendingNodeLongitude(T);\r\n    let DeltaEpsilon = 0;\r\n    let cosArg;\r\n    for (let i = 0; i < 63; i++) {\r\n        cosArg = constants.nutations[i][0] * D + constants.nutations[i][1] * M + constants.nutations[i][2] * MPrime +\r\n            constants.nutations[i][3] * F + constants.nutations[i][4] * Omega;\r\n        DeltaEpsilon += (constants.nutations[i][7] + constants.nutations[i][8] * T) * cosd(cosArg);\r\n    }\r\n    return DeltaEpsilon / 36000000;\r\n};\r\n\r\n/**\r\n * Calculates the argument of latitude of the moon (see AA p144).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Argument of latitude of the moon.\r\n */\r\nconst moonArgumentOfLatitude = (T: number): number => {\r\n    const F = polynomial(T, constants.moonArgumentOfLatitude);\r\n    return reduceAngle(F);\r\n};\r\n\r\n/**\r\n * Calculates the longitude of the ascending node of the Moon's mean orbit on\r\n * the ecliptic, measured from the mean equinox of the datea (see AA p144).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Longitude of the asc. node of the moon's mean orbit.\r\n */\r\nconst moonAscendingNodeLongitude = (T: number): number => {\r\n    const Omega = polynomial(T, constants.moonAscendingNodeLongitude);\r\n    return reduceAngle(Omega);\r\n};\r\n\r\n/**\r\n * Calculates the mean anomaly of the moon (see AA p144).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Mean anomaly of the moon.\r\n */\r\nconst moonMeanAnomaly = (T: number): number => {\r\n    const MPrime = polynomial(T, constants.moonMeanAnomaly);\r\n    return reduceAngle(MPrime);\r\n};\r\n\r\n/**\r\n * Calculates the mean elongation of the moon from the sun (see AA p144).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Mean elongation of the moon from the sun.\r\n */\r\nconst moonMeanElongation = (T: number): number => {\r\n    const D = polynomial(T, constants.moonMeanElongation);\r\n    return reduceAngle(D);\r\n};\r\n\r\n/**\r\n * Calculates the mean anomaly of the sun (see AA p144).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Mean anomaly of the sun.\r\n */\r\nconst sunMeanAnomaly = (T: number): number => {\r\n    const M = polynomial(T, constants.sunMeanAnomaly);\r\n    return reduceAngle(M);\r\n};\r\n\r\n/**\r\n * Calculates the mean longitude of the sun referred to the mean equinox of the\r\n * date (see AA p163).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Mean longitude of the sun referred to the mean equinox of\r\n *     the date.\r\n */\r\nconst sunMeanLongitude = (T: number): number => {\r\n    const L0 = polynomial(T, constants.sunMeanLongitude);\r\n    return reduceAngle(L0);\r\n};\r\n\r\nconst noEventCodes = {\r\n    SUN_HIGH: 'SUN_HIGH',\r\n    SUN_LOW: 'SUN_LOW',\r\n};\r\n\r\nexport { sunRiseSet, sunTransit, handleNoEventCase };\r\n","import { cosd, sind } from './auxMath';\r\nimport { MoonPhaseNumber } from './types';\r\nimport { kToT } from './timeConversions';\r\n\r\n/**\r\n * Calculates the Julian date in ephemeris time of the moon near the date\r\n * corresponding to k (see AA p350ff).\r\n * @param {number} k The approximate fractional number of new moons since\r\n *     2000-01-06.\r\n * @param {number} phase 0 -> new moon, 1 -> first quarter,\r\n *                       2 -> full moon, 3 -> last quarter.\r\n * @returns {number} Julian date in ephemeris time of the moon of given phase.\r\n */\r\nconst truePhase = (k: number, phase: MoonPhaseNumber): number => {\r\n    k += phase / 4;\r\n    const T = kToT(k);\r\n    const E = eccentricityCorrection(T);\r\n    const JDE = meanPhase(T, k);\r\n    const M = sunMeanAnomaly(T, k);\r\n    const MPrime = moonMeanAnomaly(T, k);\r\n    const F = moonArgumentOfLatitude(T, k);\r\n    const Omega = moonAscendingNodeLongitude(T, k);\r\n    let DeltaJDE = 0;\r\n    if (phase === 0 || phase === 2) {\r\n        DeltaJDE += newMoonFullMoonCorrections(E, M, MPrime, F, Omega, phase);\r\n    } else /* istanbul ignore else */ if (phase === 1 || phase === 3) {\r\n        DeltaJDE += quarterCorrections(E, M, MPrime, F, Omega, phase);\r\n    }\r\n    DeltaJDE += commonCorrections(T, k);\r\n    return JDE + DeltaJDE;\r\n};\r\n\r\n/**\r\n * Calculates the mean phase of the moon as Julian date in ephemeris time (see\r\n * AA p349 Eq49.1).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @param {number} k The approximate fractional number of new moons since\r\n *     2000-01-06.\r\n * @returns {number} Julian date in ephemeris time of the moon of given mean\r\n *     phase.\r\n */\r\nconst meanPhase = (T: number, k: number): number => 2451550.09766 + 29.530588861 * k + 0.00015437 * T ** 2 -\r\n    0.000000150 * T ** 3 + 0.00000000073 * T ** 4;\r\n\r\n/**\r\n * Calculates the mean anomaly of the sun (see AA p350 Eq49.4).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @param {number} k The approximate fractional number of new moons since\r\n *     2000-01-06.\r\n * @returns {number} Mean anomaly of the sun at the given time.\r\n */\r\nconst sunMeanAnomaly = (T: number, k: number): number => 2.5534 + 29.10535670 * k - 0.0000014 * T ** 2 -\r\n    0.00000011 * T ** 3;\r\n\r\n/**\r\n * Calculates the mean anomaly of the moon (see AA p350 Eq49.5).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @param {number} k The approximate fractional number of new moons since\r\n *     2000-01-06.\r\n * @returns {number} Mean anomaly of the moon at the given time.\r\n */\r\nconst moonMeanAnomaly = (T: number, k: number): number => 201.5643 + 385.81693528 * k + 0.0107582 * T ** 2 +\r\n    0.00001238 * T ** 3 - 0.000000058 * T ** 4;\r\n\r\n/**\r\n * Calculates the argument of latitude of the moon (see AA p350 Eq49.6).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @param {number} k The approximate fractional number of new moons since\r\n *     2000-01-06.\r\n * @returns {number} Argument of latitude of the moon at the given time.\r\n */\r\nconst moonArgumentOfLatitude = (T: number, k: number): number => 160.7108 + 390.67050284 * k - 0.0016118 * T ** 2 -\r\n    0.00000227 * T ** 3 + 0.000000011 * T ** 4;\r\n\r\n/**\r\n * Calculates the longitude of the ascending node of the lunar orbit (see AA\r\n * p350 Eq49.7).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @param {number} k The approximate fractional number of new moons since\r\n *     2000-01-06.\r\n * @returns {number} Longitude of the ascending node of the lunar orbit at the\r\n *     given time.\r\n */\r\nconst moonAscendingNodeLongitude = (T: number, k: number): number => 124.7746 - 1.56375588 * k + 0.0020672 * T ** 2 +\r\n    0.00000215 * T ** 3;\r\n\r\n/**\r\n * Calculates the correction for the eccentricity of the earth's orbit.\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @returns {number} Eccentricity correction.\r\n */\r\nconst eccentricityCorrection = (T: number): number => 1 - 0.002516 * T - 0.0000074 * T ** 2;\r\n\r\n/**\r\n * Calculates the corrections to the planetary arguments for the moon phases\r\n * that are common to all phases (see AA p352).\r\n * @param {number} T Fractional number of Julian centuries since\r\n *     2000-01-01T12:00:00Z.\r\n * @param {number} k The approximate fractional number of new moons since\r\n *     2000-01-06.\r\n * @returns {number} Correction to the Julian date in ephemeris time for the\r\n *     moon phase.\r\n */\r\nconst commonCorrections = (T: number, k: number): number => {\r\n    const A = [\r\n        0,\r\n        299.77 + 0.107408 * k - 0.009173 * T ** 2,\r\n        251.88 + 0.016321 * k,\r\n        251.83 + 26.651886 * k,\r\n        349.42 + 36.412478 * k,\r\n        84.66 + 18.206239 * k,\r\n        141.74 + 53.303771 * k,\r\n        207.14 + 2.453732 * k,\r\n        154.84 + 7.306860 * k,\r\n        34.52 + 27.261239 * k,\r\n        207.19 + 0.121824 * k,\r\n        291.34 + 1.844379 * k,\r\n        161.72 + 24.198154 * k,\r\n        239.56 + 25.513099 * k,\r\n        331.55 + 3.592518 * k];\r\n    return 0.000325 * sind(A[1]) + 0.000165 * sind(A[2]) + 0.000164 * sind(A[3]) + 0.000126 * sind(A[4]) +\r\n        0.000110 * sind(A[5]) + 0.000062 * sind(A[6]) + 0.000060 * sind(A[7]) + 0.000056 * sind(A[8]) +\r\n        0.000047 * sind(A[9]) + 0.000042 * sind(A[10]) + 0.000040 * sind(A[11]) + 0.000037 * sind(A[12]) +\r\n        0.000035 * sind(A[13]) + 0.000023 * sind(A[14]);\r\n};\r\n\r\n/**\r\n * Calculates the corrections to the planetary arguments for the moon phases\r\n * for full and new moons (see AA p351).\r\n * @param {number} E Correction for the eccentricity of the earth's orbit.\r\n * @param {number} M Mean anomaly of the sun.\r\n * @param {number} MPrime Mean anomaly of the moon.\r\n * @param {number} F Argument of latitude of the moon.\r\n * @param {number} Omega Longitude of the ascending node of the lunar orbit.\r\n * @param {number} phase 0 -> new moon, 1 -> first quarter,\r\n *                    2 -> full moon, 3 -> last quarter.\r\n * @returns {number} Correction to the Julian date in ephemeris time for the\r\n *     moon phase.\r\n */\r\nconst newMoonFullMoonCorrections = (E: number, M: number, MPrime: number, F: number, Omega: number, phase: number):\r\n    number => {\r\n    let DeltaJDE =\r\n        -0.00111 * sind(MPrime - 2 * F) -\r\n        0.00057 * sind(MPrime + 2 * F) +\r\n        0.00056 * E * sind(2 * MPrime + M) -\r\n        0.00042 * sind(3 * MPrime) +\r\n        0.00042 * E * sind(M + 2 * F) +\r\n        0.00038 * E * sind(M - 2 * F) -\r\n        0.00024 * E * sind(2 * MPrime - M) -\r\n        0.00017 * sind(Omega) -\r\n        0.00007 * sind(MPrime + 2 * M) +\r\n        0.00004 * sind(2 * MPrime - 2 * F) +\r\n        0.00004 * sind(3 * M) +\r\n        0.00003 * sind(MPrime + M - 2 * F) +\r\n        0.00003 * sind(2 * MPrime + 2 * F) -\r\n        0.00003 * sind(MPrime + M + 2 * F) +\r\n        0.00003 * sind(MPrime - M + 2 * F) -\r\n        0.00002 * sind(MPrime - M - 2 * F) -\r\n        0.00002 * sind(3 * MPrime + M) +\r\n        0.00002 * sind(4 * MPrime);\r\n    if (phase === 0) {\r\n        DeltaJDE +=\r\n            -0.40720 * sind(MPrime) +\r\n            0.17241 * E * sind(M) +\r\n            0.01608 * sind(2 * MPrime) +\r\n            0.01039 * sind(2 * F) +\r\n            0.00739 * E * sind(MPrime - M) -\r\n            0.00514 * E * sind(MPrime + M) +\r\n            0.00208 * E * E * sind(2 * M);\r\n    } else /* istanbul ignore else */ if (phase === 2) {\r\n        DeltaJDE +=\r\n            -0.40614 * sind(MPrime) +\r\n            0.17302 * E * sind(M) +\r\n            0.01614 * sind(2 * MPrime) +\r\n            0.01043 * sind(2 * F) +\r\n            0.00734 * E * sind(MPrime - M) -\r\n            0.00515 * E * sind(MPrime + M) +\r\n            0.00209 * E * E * sind(2 * M);\r\n    }\r\n    return DeltaJDE;\r\n};\r\n\r\n/**\r\n * Calculates the corrections to the planetary arguments for the moon phases\r\n * for first and last quarters (see AA p352).\r\n * @param {number} E Correction for the eccentricity of the earth's orbit.\r\n * @param {number} M Mean anomaly of the sun.\r\n * @param {number} MPrime Mean anomaly of the moon.\r\n * @param {number} F Argument of latitude of the moon.\r\n * @param {number} Omega Longitude of the ascending node of the lunar orbit.\r\n * @param {number} phase 0 -> new moon, 1 -> first quarter,\r\n *                    2 -> full moon, 3 -> last quarter.\r\n * @returns {number} Correction to the Julian date in ephemeris time for the\r\n *     moon phase.\r\n */\r\nconst quarterCorrections = (E: number, M: number, MPrime: number, F: number, Omega: number, phase: MoonPhaseNumber):\r\n    number => {\r\n    let DeltaJDE =\r\n        -0.62801 * sind(MPrime) +\r\n        0.17172 * E * sind(M) -\r\n        0.01183 * E * sind(MPrime + M) +\r\n        0.00862 * sind(2 * MPrime) +\r\n        0.00804 * sind(2 * F) +\r\n        0.00454 * E * sind(MPrime - M) +\r\n        0.00204 * E * E * sind(2 * M) -\r\n        0.00180 * sind(MPrime - 2 * F) -\r\n        0.00070 * sind(MPrime + 2 * F) -\r\n        0.00040 * sind(3 * MPrime) -\r\n        0.00034 * E * sind(2 * MPrime - M) +\r\n        0.00032 * E * sind(M + 2 * F) +\r\n        0.00032 * E * sind(M - 2 * F) -\r\n        0.00028 * E * E * sind(MPrime + 2 * M) +\r\n        0.00027 * E * sind(2 * MPrime + M) -\r\n        0.00017 * sind(Omega) -\r\n        0.00005 * sind(MPrime - M - 2 * F) +\r\n        0.00004 * sind(2 * MPrime + 2 * F) -\r\n        0.00004 * sind(MPrime + M + 2 * F) +\r\n        0.00004 * sind(MPrime - 2 * M) +\r\n        0.00003 * sind(MPrime + M - 2 * F) +\r\n        0.00003 * sind(3 * M) +\r\n        0.00002 * sind(2 * MPrime - 2 * F) +\r\n        0.00002 * sind(MPrime - M + 2 * F) -\r\n        0.00002 * sind(3 * MPrime + M);\r\n    const W =\r\n        0.00306 -\r\n        0.00038 * E * cosd(M) +\r\n        0.00026 * cosd(MPrime) -\r\n        0.00002 * cosd(MPrime - M) +\r\n        0.00002 * cosd(MPrime + M) +\r\n        0.00002 * cosd(2 * F);\r\n    if (phase === 1) {\r\n        DeltaJDE += W;\r\n    } else /* istanbul ignore else */ if (phase === 3) {\r\n        DeltaJDE -= W;\r\n    }\r\n    return DeltaJDE;\r\n};\r\n\r\nexport { truePhase };\r\n","import * as luxon from 'luxon';\r\nimport { DateTime, MoonPhase, MoonPhaseNumber, NoEventCode } from './types';\r\nimport { DeltaT, JDToDatetime, approxK } from './timeConversions';\r\nimport { dateFormatKeys, roundToNearestMinute, settings } from './settings';\r\nimport { handleNoEventCase, sunRiseSet, sunTransit } from './sunTimes';\r\nimport { truePhase } from './moonPhases';\r\n\r\n/**\r\n * Uses the extra information encoded into the DateTime object for dates without\r\n * a sun event if returnTimeForNoEventCase is true to mark the output string.\r\n * @param {DateTime} datetime Input datetime.\r\n * @param {string} formatString Valid DateTime format string.\r\n * @returns {string} Formatted string with marker appended.\r\n */\r\nconst format = (datetime: DateTime, formatString: string): string => {\r\n    const noEventCode = datetime.errorCode;\r\n    let datestring = datetime.toFormat(formatString);\r\n    if (dateFormatKeys[noEventCode]) {\r\n        datestring += dateFormatKeys[noEventCode];\r\n    }\r\n    return datestring;\r\n};\r\n\r\n/**\r\n * Calculates sunrise on the provided date.\r\n * @param {DateTime} datetime Datetime for which sunrise is calculated. Should\r\n *     always contain a timezone or be in UTC, lone UTC offsets might lead to\r\n *     unexpected behaviour.\r\n * @param {number} latitude Latitude of target location.\r\n * @param {number} longitude longitude of target location.\r\n * @returns {(DateTime|string)} Time of sunrise or a string indicating that no\r\n *     event could be calculated as the sun was too high ('SUN_HIGH') or too low\r\n *     ('SUN_LOW') during the entire day (unless returnTimeForNoEventCase is true).\r\n */\r\nconst sunrise = (datetime: DateTime, latitude: number, longitude: number): (DateTime | NoEventCode) => {\r\n    try {\r\n        return sunRiseSet(datetime, latitude, longitude, 'RISE');\r\n    } catch (err) {\r\n        return handleNoEventCase(datetime, err, 6);\r\n    }\r\n};\r\n\r\n/**\r\n * Calculates sunset on the provided date.\r\n * @param {DateTime} datetime Datetime for which sunset is calculated. Should\r\n *     always contain a timezone or be in UTC, lone UTC offsets might lead to\r\n *     unexpected behaviour.\r\n * @param {number} latitude Latitude of target location.\r\n * @param {number} longitude longitude of target location.\r\n * @returns {(DateTime|string)} Time of sunset or a string indicating that no\r\n *     event could be calculated as the sun was too high ('SUN_HIGH') or too low\r\n *     ('SUN_LOW') during the entire day (unless returnTimeForNoEventCase is true).\r\n */\r\nconst sunset = (datetime: DateTime, latitude: number, longitude: number): (DateTime | NoEventCode) => {\r\n    try {\r\n        return sunRiseSet(datetime, latitude, longitude, 'SET');\r\n    } catch (err) {\r\n        return handleNoEventCase(datetime, err, 18);\r\n    }\r\n};\r\n\r\n/**\r\n * Calculates civil dawn (sun 6° below horizon) on the provided date.\r\n * @param {DateTime} datetime Datetime for which civil dawn is calculated. Should\r\n *     always contain a timezone or be in UTC, lone UTC offsets might lead to\r\n *     unexpected behaviour.\r\n * @param {number} latitude Latitude of target location.\r\n * @param {number} longitude longitude of target location.\r\n * @returns {(DateTime|string)} Time of civil dawn or a string indicating that no\r\n *     event could be calculated as the sun was too high ('SUN_HIGH') or too low\r\n *     ('SUN_LOW') during the entire day (unless returnTimeForNoEventCase is true).\r\n */\r\nconst civilDawn = (datetime: DateTime, latitude: number, longitude: number): (DateTime | NoEventCode) => {\r\n    try {\r\n        return sunRiseSet(datetime, latitude, longitude, 'RISE', 6);\r\n    } catch (err) {\r\n        return handleNoEventCase(datetime, err, 5, 30);\r\n    }\r\n};\r\n\r\n/**\r\n * Calculates civil dusk (sun 6° below horizon) on the provided date.\r\n * @param {DateTime} datetime Datetime for which civil dusk is calculated. Should\r\n *     always contain a timezone or be in UTC, lone UTC offsets might lead to\r\n *     unexpected behaviour.\r\n * @param {number} latitude Latitude of target location.\r\n * @param {number} longitude longitude of target location.\r\n * @returns {(DateTime|string)} Time of civil dusk or a string indicating that no\r\n *     event could be calculated as the sun was too high ('SUN_HIGH') or too low\r\n *     ('SUN_LOW') during the entire day (unless returnTimeForNoEventCase is true).\r\n */\r\nconst civilDusk = (datetime: DateTime, latitude: number, longitude: number): (DateTime | NoEventCode) => {\r\n    try {\r\n        return sunRiseSet(datetime, latitude, longitude, 'SET', 6);\r\n    } catch (err) {\r\n        return handleNoEventCase(datetime, err, 18, 30);\r\n    }\r\n};\r\n\r\n/**\r\n * Calculates nautical dawn (sun 12° below horizon) on the provided date.\r\n * @param {DateTime} datetime Datetime for which nautical dawn is calculated.\r\n *     Should always contain a timezone or be in UTC, lone UTC offsets might\r\n *     lead to unexpected behaviour.\r\n * @param {number} latitude Latitude of target location.\r\n * @param {number} longitude longitude of target location.\r\n * @returns {(DateTime|string)} Time of nautical dawn or a string indicating that no\r\n *     event could be calculated as the sun was too high ('SUN_HIGH') or too low\r\n *     ('SUN_LOW') during the entire day (unless returnTimeForNoEventCase is true).\r\n */\r\nconst nauticalDawn = (datetime: DateTime, latitude: number, longitude: number): (DateTime | NoEventCode) => {\r\n    try {\r\n        return sunRiseSet(datetime, latitude, longitude, 'RISE', 12);\r\n    } catch (err) {\r\n        return handleNoEventCase(datetime, err, 5);\r\n    }\r\n};\r\n\r\n/**\r\n * Calculates nautical dusk (sun 12° below horizon) on the provided date.\r\n * @param {DateTime} datetime Datetime for which nautical dusk is calculated.\r\n *     Should always contain a timezone or be in UTC, lone UTC offsets might\r\n *     lead to unexpected behaviour.\r\n * @param {number} latitude Latitude of target location.\r\n * @param {number} longitude longitude of target location.\r\n * @returns {(DateTime|string)} Time of nautical dusk or a string indicating that no\r\n *     event could be calculated as the sun was too high ('SUN_HIGH') or too low\r\n *     ('SUN_LOW') during the entire day (unless returnTimeForNoEventCase is true).\r\n */\r\nconst nauticalDusk = (datetime: DateTime, latitude: number, longitude: number): (DateTime | NoEventCode) => {\r\n    try {\r\n        return sunRiseSet(datetime, latitude, longitude, 'SET', 12);\r\n    } catch (err) {\r\n        return handleNoEventCase(datetime, err, 19);\r\n    }\r\n};\r\n\r\n/**\r\n * Calculates astronomical dawn (sun 18° below horizon) on the provided date.\r\n * @param {DateTime} datetime Datetime for which astronomical dawn is calculated.\r\n *     Should always contain a timezone or be in UTC, lone UTC offsets might\r\n *     lead to unexpected behaviour.\r\n * @param {number} latitude Latitude of target location.\r\n * @param {number} longitude longitude of target location.\r\n * @returns {(DateTime|string)} Time of astronomical dawn or a string indicating that no\r\n *     event could be calculated as the sun was too high ('SUN_HIGH') or too low\r\n *     ('SUN_LOW') during the entire day (unless returnTimeForNoEventCase is true).\r\n */\r\nconst astronomicalDawn = (datetime: DateTime, latitude: number, longitude: number): (DateTime | NoEventCode) => {\r\n    try {\r\n        return sunRiseSet(datetime, latitude, longitude, 'RISE', 18);\r\n    } catch (err) {\r\n        return handleNoEventCase(datetime, err, 4, 30);\r\n    }\r\n};\r\n\r\n/**\r\n * Calculates astronomical dusk (sun 18° below horizon) on the provided date.\r\n * @param {DateTime} datetime Datetime for which astronomical dusk is calculated.\r\n *     Should always contain a timezone or be in UTC, lone UTC offsets might\r\n *     lead to unexpected behaviour.\r\n * @param {number} latitude Latitude of target location.\r\n * @param {number} longitude longitude of target location.\r\n * @returns {(DateTime|string)} Time of astronomical dusk or a string indicating that no\r\n *     event could be calculated as the sun was too high ('SUN_HIGH') or too low\r\n *     ('SUN_LOW') during the entire day (unless returnTimeForNoEventCase is true).\r\n */\r\nconst astronomicalDusk = (datetime: DateTime, latitude: number, longitude: number): (DateTime | NoEventCode) => {\r\n    try {\r\n        return sunRiseSet(datetime, latitude, longitude, 'SET', 18);\r\n    } catch (err) {\r\n        return handleNoEventCase(datetime, err, 19, 30);\r\n    }\r\n};\r\n\r\n/**\r\n * Calculates solar noon on the provided date.\r\n * @param {DateTime} datetime Datetime for which solar noon is calculated. Should\r\n *     always contain a timezone or be in UTC, lone UTC offsets might lead to\r\n *     unexpected behaviour.\r\n * @param {number} longitude longitude of target location.\r\n * @returns {DateTime} Time of solar noon at the given longitude.\r\n */\r\nconst solarNoon = (datetime: DateTime, longitude: number): DateTime => sunTransit(datetime, longitude);\r\n\r\n/**\r\n * Calculates all moons of the given phase that occur within the given\r\n * Gregorian calendar year.\r\n * @param {number} year Year for which moon phases should be calculated.\r\n * @param {number} phase 0 -> new moon, 1 -> first quarter,\r\n *                    2 -> full moon, 3 -> last quarter.\r\n * @param {string} timezone Optional: IANA timezone string.\r\n * @returns {array} Array of DateTime objects for moons of the given phase.\r\n */\r\nconst yearMoonPhases = (year: number, phase: MoonPhaseNumber, timezone: string = 'UTC'): Array<DateTime> => {\r\n    const yearBegin = luxon.DateTime.fromObject(\r\n        // eslint-disable-next-line sort-keys\r\n        { year, month: 1, day: 1, hour: 0, minute: 0, second: 0, zone: timezone });\r\n    const yearEnd = luxon.DateTime.fromObject(\r\n        // eslint-disable-next-line sort-keys\r\n        { year: year + 1, month: 1, day: 1, hour: 0, minute: 0, second: 0, zone: timezone });\r\n    // this will give us k for the first new moon of the year or earlier\r\n    let k = Math.floor(approxK(yearBegin)) - 1;\r\n    // taking 15 events will make sure we catch every event in the year\r\n    const phaseTimes = [];\r\n    let JDE;\r\n    let moonDatetime;\r\n    let deltaT;\r\n    for (let i = 0; i < 15; i++) {\r\n        JDE = truePhase(k, phase);\r\n        // we pretend it's JD and not JDE\r\n        moonDatetime = JDToDatetime(JDE).setZone(timezone);\r\n        // now use that to calculate deltaT\r\n        deltaT = DeltaT(moonDatetime);\r\n        if (deltaT > 0) {\r\n            moonDatetime = moonDatetime.minus({ seconds: Math.round(Math.abs(deltaT)) });\r\n        } else {\r\n            moonDatetime = moonDatetime.plus({ seconds: Math.round(Math.abs(deltaT)) });\r\n        }\r\n        if (roundToNearestMinute) {\r\n            moonDatetime = moonDatetime.plus({ seconds: 30 }).set({ second: 0 });\r\n        }\r\n        if (moonDatetime >= yearBegin && moonDatetime < yearEnd) {\r\n            phaseTimes.push(moonDatetime);\r\n        }\r\n        k++;\r\n    }\r\n    return phaseTimes;\r\n};\r\n\r\nconst yearAllMoonPhases = (year: number, timezone: string = 'UTC'): Array<MoonPhase> => [\r\n    ...yearMoonPhases(year, 0, timezone).map((datetime) => ({ datetime, phase: 0 as MoonPhaseNumber })),\r\n    ...yearMoonPhases(year, 1, timezone).map((datetime) => ({ datetime, phase: 1 as MoonPhaseNumber })),\r\n    ...yearMoonPhases(year, 2, timezone).map((datetime) => ({ datetime, phase: 2 as MoonPhaseNumber })),\r\n    ...yearMoonPhases(year, 3, timezone).map((datetime) => ({ datetime, phase: 3 as MoonPhaseNumber })),\r\n].sort((a, b) => a.datetime.valueOf() - b.datetime.valueOf());\r\n\r\nexport {\r\n    format, sunrise, sunset, civilDawn, civilDusk, nauticalDawn, nauticalDusk, astronomicalDawn, astronomicalDusk,\r\n    solarNoon, yearMoonPhases, yearAllMoonPhases, settings,\r\n};\r\n"],"names":["deg2rad","deg","rad2deg","rad","sind","Math","sin","cosd","cos","reduceAngle","angle","floor","polynomial","variable","coeffs","varPower","reduce","accumulator","currentValue","interpolateFromThree","y1","y2","y3","n","normalize","a","b","JDToDatetime","JD","Z","F","A","alpha","B","C","D","E","fracDay","day","hour","minute","second","month","year","DateTime","fromISO","zone","set","datetimeToT","datetime","Y","M","datetimeToJD","DeltaT","u","t","y","RangeError","roundToNearestMinute","returnTimeForNoEventCase","dateFormatKeys","SUN_HIGH","SUN_LOW","settings","sunMeanAnomaly","sunMeanLongitude","meanObliquityOfEcliptic","moonArgumentOfLatitude","moonAscendingNodeLongitude","moonMeanAnomaly","moonMeanElongation","nutations","sunRiseSet","phi","L","flag","offset","timezone","suntime","millisecond","setZone","keepLocalTime","deltaT","T","Theta0","apparentSiderealTimeGreenwich","TD","sunApparentRightAscension","delta","sunApparentDeclination","H0","approxLocalHourAngle","m","m0","normalizeM","counter","DeltaM","abs","sunRiseSetCorrection","plus","seconds","minus","handleNoEventCase","date","errorCode","returnDate","minutes","isInDST","cosH0","noEventCodes","acos","utcOffset","localM","sunTransitCorrection","theta0","interpolatedRa","localHourAngle","interpolatedDec","H","altitude","asin","alpha1","alpha2","alpha3","delta1","delta2","delta3","Omega","epsilon","trueObliquityOfEcliptic","lambda","sunApparentLongitude","atan2","meanSiderealTimeGreenwich","theta","nutationInLongitude","nutationInObliquity","constants.meanObliquityOfEcliptic","Sol","sunTrueLongitude","sunEquationOfCenter","MPrime","sineArg","DeltaPsi","i","constants.nutations","cosArg","DeltaEpsilon","constants.moonArgumentOfLatitude","constants.moonAscendingNodeLongitude","constants.moonMeanAnomaly","constants.moonMeanElongation","constants.sunMeanAnomaly","L0","constants.sunMeanLongitude","truePhase","k","phase","kToT","eccentricityCorrection","JDE","meanPhase","DeltaJDE","newMoonFullMoonCorrections","quarterCorrections","commonCorrections","W","format","formatString","noEventCode","datestring","toFormat","sunrise","latitude","longitude","err","sunset","civilDawn","civilDusk","nauticalDawn","nauticalDusk","astronomicalDawn","astronomicalDusk","solarNoon","transit","sunTransit","yearMoonPhases","yearBegin","luxon.DateTime","fromObject","yearEnd","phaseTimes","moonDatetime","round","push","yearAllMoonPhases","map","sort","valueOf"],"mappings":"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"}